import { NextResponse } from 'next/server';

const MALWAREBAZAAR_CSV = 'https://bazaar.abuse.ch/export/csv/recent/';

interface MalwareSample {
  id: string;
  sha256Hash: string;
  md5Hash: string;
  sha1Hash: string;
  fileName: string;
  fileType: string;
  signature: string;
  firstSeen: string;
  originCountry: string;
  threatLevel: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  threatScore: number;
  tags: string[];
  reporter: string;
}

const CRITICAL_PATTERNS = ['ransomware', 'ransom', 'lockbit', 'blackcat', 'alphv', 'clop', 'revil', 'conti', 'darkside', 'ryuk', 'wannacry', 'notpetya', 'maze'];
const HIGH_PATTERNS = ['trojan', 'backdoor', 'rat ', 'remoteadmin', 'cobalt', 'keylogger', 'stealer', 'banker', 'botnet', 'mirai', 'emotet', 'trickbot', 'qakbot', 'dridex', 'formbook', 'snake', 'loader', 'downloader', 'dropper', 'rootkit', 'spyware', 'worm'];
const MEDIUM_PATTERNS = ['adware', 'miner', 'xmrig', 'pup', 'riskware', 'hacktool', 'nircmd', 'nirsoft', 'tool'];

function calculateThreatLevel(signature: string, tags: string[]): MalwareSample['threatLevel'] {
  const sig = signature.toLowerCase();
  if (CRITICAL_PATTERNS.some(p => sig.includes(p)) || tags.includes('ransomware')) return 'CRITICAL';
  if (HIGH_PATTERNS.some(p => sig.includes(p)) || tags.includes('apt') || tags.includes('trojan')) return 'HIGH';
  if (MEDIUM_PATTERNS.some(p => sig.includes(p)) || tags.includes('cryptominer')) return 'MEDIUM';
  if (sig === 'n/a' || sig === 'unknown') return 'LOW';
  // Named/known signature = at least medium
  return 'MEDIUM';
}

function calculateThreatScore(signature: string, tags: string[]): number {
  let score = 20;
  const sig = signature.toLowerCase();
  if (CRITICAL_PATTERNS.some(p => sig.includes(p))) score += 55;
  else if (HIGH_PATTERNS.some(p => sig.includes(p))) score += 40;
  else if (MEDIUM_PATTERNS.some(p => sig.includes(p))) score += 20;
  else if (sig !== 'n/a' && sig !== 'unknown') score += 15;
  if (tags.includes('apt')) score += 15;
  if (tags.includes('exploit')) score += 20;
  if (tags.includes('zero-day')) score += 25;
  if (tags.includes('fileless')) score += 15;
  return Math.min(score, 100);
}

function parseCSV(csv: string): MalwareSample[] {
  const lines = csv.split('\n').filter(line => line && !line.startsWith('#'));
  const samples: MalwareSample[] = [];

  // Skip header line
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;

    // Parse quoted CSV fields
    const fields: string[] = [];
    let current = '';
    let inQuotes = false;
    for (let j = 0; j < line.length; j++) {
      if (line[j] === '"') {
        inQuotes = !inQuotes;
      } else if (line[j] === ',' && !inQuotes) {
        fields.push(current.trim());
        current = '';
      } else {
        current += line[j];
      }
    }
    fields.push(current.trim());

    if (fields.length < 9) continue;

    const [firstSeen, sha256Hash, md5Hash, sha1Hash, reporter, fileName, fileTypeGuess, , signature] = fields;

    const sig = signature || 'Unknown';
    const tags: string[] = [];
    if (sig.toLowerCase().includes('ransomware')) tags.push('ransomware');
    if (sig.toLowerCase().includes('trojan')) tags.push('trojan');
    if (sig.toLowerCase().includes('backdoor')) tags.push('backdoor');
    if (sig.toLowerCase().includes('miner')) tags.push('cryptominer');
    if (sig.toLowerCase().includes('apt') || sig.toLowerCase().includes('cobalt')) tags.push('apt');

    samples.push({
      id: sha256Hash.substring(0, 16),
      sha256Hash,
      md5Hash,
      sha1Hash,
      fileName: fileName || 'unknown',
      fileType: fileTypeGuess || 'unknown',
      signature: sig,
      firstSeen: firstSeen ? new Date(firstSeen).toISOString() : new Date().toISOString(),
      originCountry: 'Unknown',
      threatLevel: calculateThreatLevel(sig, tags),
      threatScore: calculateThreatScore(sig, tags),
      tags,
      reporter: reporter || 'unknown',
    });
  }

  return samples;
}

export async function GET() {
  try {
    const response = await fetch(MALWAREBAZAAR_CSV, {
      headers: { 'User-Agent': 'ThreatPulse-Hub/1.0' },
      next: { revalidate: 300 }, // Cache for 5 minutes
    });

    if (!response.ok) {
      return NextResponse.json({ error: 'Failed to fetch from MalwareBazaar' }, { status: 502 });
    }

    const csv = await response.text();
    const samples = parseCSV(csv).slice(0, 100); // Return up to 100 most recent

    return NextResponse.json({
      success: true,
      count: samples.length,
      fetchedAt: new Date().toISOString(),
      samples,
    });
  } catch (error) {
    console.error('Error fetching MalwareBazaar:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
