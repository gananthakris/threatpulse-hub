import { Handler, ScheduledEvent } from 'aws-lambda';
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient, PutCommand, ScanCommand } from '@aws-sdk/lib-dynamodb';
import { v4 as uuidv4 } from 'uuid';

const client = new DynamoDBClient({});
const docClient = DynamoDBDocumentClient.from(client);

// MalwareBazaar API endpoint
const MALWAREBAZAAR_API = 'https://mb-api.abuse.ch/api/v1/';

interface MalwareSample {
  sha256_hash: string;
  sha1_hash?: string;
  md5_hash?: string;
  file_name?: string;
  file_size?: number;
  file_type?: string;
  file_type_mime?: string;
  signature?: string;
  clamav?: string;
  first_seen?: string;
  last_seen?: string;
  reporter?: string;
  origin_country?: string;
  imphash?: string;
  tlsh?: string;
  telfhash?: string;
  gimphash?: string;
  dhash_icon?: string;
  tags?: string[];
  delivery_method?: string;
  intelligence?: any;
}

function calculateThreatLevel(sample: MalwareSample): string {
  // Determine threat level based on signature and tags
  const signature = sample.signature?.toLowerCase() || '';
  const tags = sample.tags || [];
  
  if (signature.includes('ransomware') || tags.includes('ransomware')) {
    return 'CRITICAL';
  }
  if (signature.includes('trojan') || signature.includes('backdoor') || 
      tags.includes('apt') || tags.includes('trojan')) {
    return 'HIGH';
  }
  if (signature.includes('adware') || signature.includes('miner') || 
      tags.includes('cryptominer')) {
    return 'MEDIUM';
  }
  return 'LOW';
}

function calculateThreatScore(sample: MalwareSample): number {
  let score = 30; // Base score
  
  const signature = sample.signature?.toLowerCase() || '';
  const tags = sample.tags || [];
  
  // Signature-based scoring
  if (signature.includes('ransomware')) score += 40;
  if (signature.includes('trojan')) score += 30;
  if (signature.includes('backdoor')) score += 35;
  if (signature.includes('rootkit')) score += 35;
  if (signature.includes('botnet')) score += 30;
  if (signature.includes('miner')) score += 15;
  if (signature.includes('adware')) score += 10;
  
  // Tag-based scoring
  if (tags.includes('apt')) score += 20;
  if (tags.includes('exploit')) score += 25;
  if (tags.includes('zero-day')) score += 30;
  if (tags.includes('fileless')) score += 20;
  
  // Cap at 100
  return Math.min(score, 100);
}

async function fetchRecentSamples(limit: number = 100): Promise<MalwareSample[]> {
  try {
    const response = await fetch(MALWAREBAZAAR_API, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: `query=get_recent&selector=time&limit=${limit}`
    });

    if (!response.ok) {
      throw new Error(`API request failed with status ${response.status}`);
    }

    const data = await response.json();
    
    if (data.query_status === 'ok' && data.data) {
      return data.data;
    }
    
    return [];
  } catch (error) {
    console.error('Error fetching from MalwareBazaar:', error);
    return [];
  }
}

async function fetchByTag(tag: string, limit: number = 50): Promise<MalwareSample[]> {
  try {
    const response = await fetch(MALWAREBAZAAR_API, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: `query=get_taginfo&tag=${tag}&limit=${limit}`
    });

    if (!response.ok) {
      throw new Error(`API request failed with status ${response.status}`);
    }

    const data = await response.json();
    
    if (data.query_status === 'ok' && data.data) {
      return data.data;
    }
    
    return [];
  } catch (error) {
    console.error(`Error fetching tag ${tag}:`, error);
    return [];
  }
}

async function checkExistingSample(tableName: string, sha256Hash: string): Promise<boolean> {
  try {
    const scanResult = await docClient.send(new ScanCommand({
      TableName: tableName,
      FilterExpression: 'sha256Hash = :hash',
      ExpressionAttributeValues: {
        ':hash': sha256Hash
      },
      Limit: 1
    }));
    
    return (scanResult.Items && scanResult.Items.length > 0);
  } catch (error) {
    console.error('Error checking existing sample:', error);
    return false;
  }
}

async function saveSample(tableName: string, sample: MalwareSample): Promise<void> {
  // Check if sample already exists
  const exists = await checkExistingSample(tableName, sample.sha256_hash);
  if (exists) {
    console.log(`Sample ${sample.sha256_hash} already exists, skipping...`);
    return;
  }

  const item = {
    id: uuidv4(),
    sha256Hash: sample.sha256_hash,
    sha1Hash: sample.sha1_hash,
    md5Hash: sample.md5_hash,
    fileName: sample.file_name || 'unknown',
    fileSize: sample.file_size,
    fileType: sample.file_type,
    fileTypeMime: sample.file_type_mime,
    signature: sample.signature || 'Unknown',
    clamav: sample.clamav,
    firstSeen: sample.first_seen || new Date().toISOString(),
    lastSeen: sample.last_seen,
    reporter: sample.reporter,
    originCountry: sample.origin_country || 'Unknown',
    imphash: sample.imphash,
    tlsh: sample.tlsh,
    telfhash: sample.telfhash,
    gimphash: sample.gimphash,
    dhashIcon: sample.dhash_icon,
    tags: sample.tags || [],
    deliveryMethod: sample.delivery_method,
    intelligence: sample.intelligence,
    threatScore: calculateThreatScore(sample),
    threatLevel: calculateThreatLevel(sample),
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  };

  try {
    await docClient.send(new PutCommand({
      TableName: tableName,
      Item: item,
    }));
    console.log(`Saved sample: ${sample.sha256_hash}`);
  } catch (error) {
    console.error(`Error saving sample ${sample.sha256_hash}:`, error);
  }
}

export const handler: Handler = async (event: ScheduledEvent) => {
  console.log('Starting MalwareBazaar collection...');
  
  const tableName = process.env.MALWARE_SAMPLE_TABLE_NAME;
  
  if (!tableName) {
    console.error('MALWARE_SAMPLE_TABLE_NAME environment variable not set');
    return {
      statusCode: 500,
      body: JSON.stringify({ error: 'Table name not configured' })
    };
  }

  let totalSamples = 0;
  let newSamples = 0;

  try {
    // Fetch recent samples
    console.log('Fetching recent samples...');
    const recentSamples = await fetchRecentSamples(100);
    totalSamples += recentSamples.length;
    
    for (const sample of recentSamples) {
      const exists = await checkExistingSample(tableName, sample.sha256_hash);
      if (!exists) {
        await saveSample(tableName, sample);
        newSamples++;
      }
    }

    // Fetch samples by important tags
    const importantTags = ['ransomware', 'apt', 'trojan', 'backdoor', 'exploit'];
    
    for (const tag of importantTags) {
      console.log(`Fetching samples for tag: ${tag}...`);
      const tagSamples = await fetchByTag(tag, 20);
      totalSamples += tagSamples.length;
      
      for (const sample of tagSamples) {
        const exists = await checkExistingSample(tableName, sample.sha256_hash);
        if (!exists) {
          await saveSample(tableName, sample);
          newSamples++;
        }
      }
    }

    console.log(`Collection complete. Total: ${totalSamples}, New: ${newSamples}`);
    
    return {
      statusCode: 200,
      body: JSON.stringify({
        success: true,
        message: `Collected ${newSamples} new samples from ${totalSamples} total`,
        totalSamples,
        newSamples,
        timestamp: new Date().toISOString()
      })
    };
  } catch (error) {
    console.error('Collection failed:', error);
    return {
      statusCode: 500,
      body: JSON.stringify({
        success: false,
        error: 'Collection failed',
        message: error instanceof Error ? error.message : 'Unknown error'
      })
    };
  }
};